name: Generate and Commit Dataset Metadata

on:
  pull_request:
    branches: [ main ]
    types: [ opened, synchronize, reopened ]
    paths:
      - '*/metadata.json'
      - '.github/workflows/gen-metadata.yml'

jobs:
  generate-metadata:
    if: github.actor != 'mlc-r2-infra[bot]'
    runs-on: ubuntu-latest
    environment: r2-deploy
    permissions:
      contents: write   # allow pushing back to the PR branch
      issues: write     # allow workflow to post/update PR comments
      pull-requests: write # needed for PR comment APIs when using pull_request event

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          persist-credentials: false

      - name: Load R2 secrets from 1Password
        id: op-load-secret
        uses: 1password/load-secrets-action@v2
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          R2_ACCESS_KEY_ID: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/vsktfcerr4lzwelblqsdzio5ku
          R2_SECRET_ACCESS_KEY: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/ddid5yjvyyzobwvxghauuxs4vu
          R2_ENDPOINT: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/cwrkc6c564ds47q3ofajxgzkaa
          APP_PRIVATE_KEY: "op://mqgmk3badhri6yvwi3qknilwz4/v7kvdlzwlj23nf6r4r5t3taf2e/private key"
          APP_ID: "op://mqgmk3badhri6yvwi3qknilwz4/v7kvdlzwlj23nf6r4r5t3taf2e/App ID"

      - name: Install rclone
        run: |
          sudo -v ; curl https://rclone.org/install.sh | sudo bash
          rclone version

      - name: Configure temporary rclone remote
        run: |
          rclone config create r2-meta s3 \
            provider=Cloudflare \
            access_key_id="${{ steps.op-load-secret.outputs.R2_ACCESS_KEY_ID }}" \
            secret_access_key="${{ steps.op-load-secret.outputs.R2_SECRET_ACCESS_KEY }}" \
            endpoint="${{ steps.op-load-secret.outputs.R2_ENDPOINT }}" \
            no_check_bucket=true --non-interactive
          rclone listremotes

      - name: Generate metadata files for all datasets
        run: |
          set -euo pipefail

          for json in */metadata.json; do
            # Skip central resources folder if present
            [[ "$json" == "central/metadata.json" ]] && continue

            folder="$(dirname "$json")"  # e.g., 'waymo'
            META_DIR="${folder}/metadata"
            mkdir -p "$META_DIR"

            ROOT_BUCKET=$(jq -r '.bucket' "$json")
            ROOT_DOMAIN=$(jq -r '.domain' "$json")

            echo "ðŸ“‚ Processing $folder (bucket: $ROOT_BUCKET)"

            mapfile -t DATASETS < <(jq -c '.datasets[]' "$json")
            for dataset in "${DATASETS[@]}"; do
              name=$(echo "$dataset" | jq -r '.name')
              subpath=$(echo "$dataset" | jq -r '.subpath')

              # Trim possible trailing slash from subpath for URI and bucket path
              clean_subpath="${subpath%/}"

              bucket_path="$ROOT_BUCKET/$clean_subpath"
              uri="https://${ROOT_DOMAIN}/${clean_subpath}"

              echo "  â€¢ Generating .uri for $name => $uri"
              echo "$uri" > "$META_DIR/${name}.uri"

              echo "    Generating .md5 for $name from $bucket_path (sorted)"
              if ! rclone md5sum "r2-meta:${bucket_path}" | LC_ALL=C sort > "$META_DIR/${name}.md5"; then
                echo "::error::Failed to generate MD5 list for ${name} (folder: $folder). Aborting."
                exit 1
              fi
            done
          done

      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ steps.op-load-secret.outputs.APP_ID }}
          private-key: ${{ steps.op-load-secret.outputs.APP_PRIVATE_KEY }}

      - name: Commit and push metadata files
        run: |
          git config user.name "mlc-r2-infra[bot]"
          git config user.email "218688909+mlc-r2-infra[bot]@users.noreply.github.com"

          # Ensure all subsequent git operations (commit, fetch) use the App token
          git remote set-url origin "https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${{ github.repository }}.git"

          git add */metadata/*
          git diff --cached --name-status
          if git diff --cached --quiet; then
            echo "No metadata changes to commit."
          else
            git commit -m "Add metadata files (auto-generated by workflow)" || true
            git push origin HEAD:"${GITHUB_HEAD_REF}"
          fi

      - name: Comment PR with metadata generation summary
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        with:
          script: |
            const { execSync } = require('child_process');
            // Fetch main for comparison
            execSync('git fetch --depth=1 origin main');
            const diff = execSync('git diff --name-only origin/main HEAD -- "*/metadata/*.uri" "*/metadata/*.md5"').toString().trim();
            const files = diff ? diff.split('\n') : [];

            let body = '## âœ… Metadata files generated\n\n';
            if (files.length) {
              body += '### ðŸ”„ Files changed vs `main`\n';
              files.forEach(f => body += `- \`${f}\`\n`);
            } else {
              body += 'No metadata file changes compared to main.';
            }

                    body += '\n---\n*ðŸ¤– This comment was automatically generated by the generate metadata workflow.*';

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.data.find(c => c.user.type === 'Bot' && c.body.includes('âœ… Metadata files generated'));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            } 