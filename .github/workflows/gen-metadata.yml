name: Generate and Commit Dataset Metadata

on:
  pull_request:
    branches: [ main ]
    types: [ opened, synchronize, reopened ]
    paths:
      - '*/metadata.json'

jobs:
  generate-metadata:
    runs-on: ubuntu-latest
    environment: r2-deploy
    permissions:
      contents: write   # allow pushing back to the PR branch

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}

      - name: Load R2 secrets from 1Password
        id: op-load-secret
        uses: 1password/load-secrets-action@v2
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          R2_ACCESS_KEY_ID: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/vsktfcerr4lzwelblqsdzio5ku
          R2_SECRET_ACCESS_KEY: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/ddid5yjvyyzobwvxghauuxs4vu
          R2_ENDPOINT: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/cwrkc6c564ds47q3ofajxgzkaa

      - name: Install rclone
        run: |
          sudo -v ; curl https://rclone.org/install.sh | sudo bash
          rclone version

      - name: Configure temporary rclone remote
        run: |
          rclone config create r2-meta s3 \
            provider=Cloudflare \
            access_key_id="${{ steps.op-load-secret.outputs.R2_ACCESS_KEY_ID }}" \
            secret_access_key="${{ steps.op-load-secret.outputs.R2_SECRET_ACCESS_KEY }}" \
            endpoint="${{ steps.op-load-secret.outputs.R2_ENDPOINT }}" \
            no_check_bucket=true --non-interactive
          rclone listremotes

      - name: Generate metadata files for Cognata dataset
        run: |
          set -euo pipefail
          DATASET_FILE="cognata/metadata.json"
          META_DIR="cognata/metadata"
          mkdir -p "$META_DIR"

          ROOT_BUCKET=$(jq -r '.bucket' "$DATASET_FILE")
          ROOT_DOMAIN=$(jq -r '.domain' "$DATASET_FILE")

          mapfile -t DATASETS < <(jq -c '.datasets[]' "$DATASET_FILE")
          for dataset in "${DATASETS[@]}"; do
            name=$(echo "$dataset" | jq -r '.name')
            subpath=$(echo "$dataset" | jq -r '.subpath')

            # Trim possible trailing slash from subpath for URI and bucket path
            clean_subpath="${subpath%/}"

            # Build variables
            bucket_path="$ROOT_BUCKET/$clean_subpath"
            uri="https://${ROOT_DOMAIN}/${clean_subpath}"

            echo "Generating .uri for $name => $uri"
            echo "$uri" > "$META_DIR/${name}.uri"

            echo "Generating .md5 for $name from $bucket_path"
            if ! rclone md5sum "r2-meta:${bucket_path}" > "$META_DIR/${name}.md5"; then
              echo "::error::Failed to generate MD5 list for ${name}. Aborting."
              exit 1
            fi
          done

      - name: Commit and push metadata files
        run: |
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git add cognata/metadata/*.uri || true
          git add cognata/metadata/*.md5 2>/dev/null || true
          if git diff --cached --quiet; then
            echo "No metadata changes to commit."
            exit 0
          fi
          git commit -m "auto-generate Cognata metadata files" || true

          # Push back to the PR branch
          git push origin HEAD:"${GITHUB_HEAD_REF}" 

      - name: Comment PR with metadata generation summary
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');
            // Fetch main for comparison
            execSync('git fetch --depth=1 origin main');
            const diff = execSync('git diff --name-only origin/main HEAD -- */metadata/*.uri */metadata/*.md5').toString().trim();
            const files = diff ? diff.split('\n') : [];

            let body = '## âœ… Metadata files generated\n\n';
            if (files.length) {
              body += '### Files changed vs `main`\n';
              files.forEach(f => body += `- \`${f}\`\n`);
            } else {
              body += 'No metadata file changes compared to main.';
            }

            body += '\n---\n*ðŸ¤– This comment was automatically generated by the metadata workflow.*';

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existing = comments.data.find(c => c.user.type === 'Bot' && c.body.includes('âœ… Metadata files generated'));

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
            } 