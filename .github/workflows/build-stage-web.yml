name: Build, commit, and stage web files

on:
  pull_request:
    branches: [ main ]
    types: [ opened, synchronize, reopened ]
    paths:
      - '*/manifest.json'
      - 'central/*'
      - 'templates/template-index.html'
      - '.github/scripts/generate-web-pages.sh'
      - '.github/workflows/build-stage-web.yml'

# Prevent overlapping runs on the same PR/branch
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    environment: staging-web
    permissions:
      contents: read       # allow checking out the repository
      issues: write        # allow creating/updating comments
      pull-requests: write # required for PR comments when from forks
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        ref: ${{ github.head_ref }}
        persist-credentials: false

    - name: Get directories to process
      id: dirs-to-process
      run: |
        echo "Fetching base branch main..."
        git fetch origin main --depth=1
        CHANGED_FILES=$(git diff --name-only origin/main HEAD)
        echo "Changed files:"
        echo "$CHANGED_FILES"

        PROCESS_ALL=false
        if echo "$CHANGED_FILES" | grep -q -e "^templates/" -e "^central/" -e "^\.github/scripts/generate-web-pages\.sh"; then
          PROCESS_ALL=true
          echo "Core files changed, processing all directories with a manifest."
        fi

        DIRS=""
        if [ "$PROCESS_ALL" = "true" ]; then
          DIRS=$(ls -d */ | grep -v -e 'example' -e 'templates' | sed 's|/||')
        else
          # Get directories of changed manifest.json files
          MANIFEST_DIRS=$(echo "$CHANGED_FILES" | grep 'manifest.json$' || true)
          if [ -n "$MANIFEST_DIRS" ]; then
            DIRS=$(echo "$MANIFEST_DIRS" | xargs -n1 dirname | sort -u)
            # Always include central resources when any manifest changes so staging has shared assets
            DIRS="$DIRS central"
          fi
          # If central has other changes (not manifest.json), add it
          if echo "$CHANGED_FILES" | grep -q "^central/"; then
            DIRS="$DIRS central"
          fi
          # remove duplicates and trim whitespace
          if [ -n "$DIRS" ]; then
            DIRS=$(echo $DIRS | tr ' ' '\n' | sort -u | tr '\n' ' ' | sed 's/^ *//;s/ *$//')
          fi
        fi

        echo "Directories to process: $DIRS"
        # Ensure DIRS is properly formatted for GitHub Actions output
        DIRS_CLEAN=$(echo "$DIRS" | tr '\n' ' ' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//')
        echo "dirs=$DIRS_CLEAN" >> $GITHUB_OUTPUT
        if [ -z "$DIRS" ]; then
          echo "no_dirs_to_process=true" >> $GITHUB_OUTPUT
        else
          echo "no_dirs_to_process=false" >> $GITHUB_OUTPUT
        fi
      
    - name: Load secret
      if: steps.dirs-to-process.outputs.no_dirs_to_process == 'false'
      id: op-load-secret
      uses: 1password/load-secrets-action@v3
      env:
        OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
        R2_ACCESS_KEY_ID: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/vsktfcerr4lzwelblqsdzio5ku
        R2_SECRET_ACCESS_KEY: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/ddid5yjvyyzobwvxghauuxs4vu
        R2_ENDPOINT: op://mqgmk3badhri6yvwi3qknilwz4/hjinzlouv5hekttyckgij4iyqq/f6gocg2smekpszwxqpnn7x6jga/cwrkc6c564ds47q3ofajxgzkaa
        APP_PRIVATE_KEY: "op://mqgmk3badhri6yvwi3qknilwz4/v7kvdlzwlj23nf6r4r5t3taf2e/private key"
        APP_ID: "op://mqgmk3badhri6yvwi3qknilwz4/v7kvdlzwlj23nf6r4r5t3taf2e/App ID"

    - name: Install Rclone
      if: steps.dirs-to-process.outputs.no_dirs_to_process == 'false'
      run: |
        sudo -v ; curl https://rclone.org/install.sh | sudo bash
        rclone version
        
    - name: Setup Rclone Config
      if: steps.dirs-to-process.outputs.no_dirs_to_process == 'false'
      run: |
        rclone config create r2-deploy s3 \
          provider=Cloudflare \
          access_key_id=${{ steps.op-load-secret.outputs.R2_ACCESS_KEY_ID }} \
          secret_access_key=${{ steps.op-load-secret.outputs.R2_SECRET_ACCESS_KEY }} \
          endpoint=${{ steps.op-load-secret.outputs.R2_ENDPOINT }} \
          no_check_bucket=true
        rclone listremotes

    - name: Generate index.html pages
      if: steps.dirs-to-process.outputs.no_dirs_to_process == 'false'
      run: |
        chmod +x .github/scripts/generate-web-pages.sh
        .github/scripts/generate-web-pages.sh
        
    - name: Generate GitHub App token
      if: steps.dirs-to-process.outputs.no_dirs_to_process == 'false'
      id: app-token
      uses: actions/create-github-app-token@v2
      with:
        app-id: ${{ steps.op-load-secret.outputs.APP_ID }}
        private-key: ${{ steps.op-load-secret.outputs.APP_PRIVATE_KEY }}

    - name: Commit index.html files
      if: steps.dirs-to-process.outputs.no_dirs_to_process == 'false'
      run: |
        # Configure git user
        git config user.name "mlc-r2-infra[bot]"
        git config user.email "218688909+mlc-r2-infra[bot]@users.noreply.github.com"
        
        # Point 'origin' to use the App token for authentication
        git remote set-url origin "https://x-access-token:${{ steps.app-token.outputs.token }}@github.com/${{ github.repository }}.git"
        
        # Add, commit, and push the generated index.html files
        git add '*/index.html'
        
        # Check if there are any changes to commit
        if git diff --cached --quiet; then
          echo "No generated index.html files to commit."
        else
          echo "Committing updated index.html files..."
          git commit -m "$(printf 'Commit index.html files (auto-generated by workflow)\n\n[skip ci]')"
          git push origin HEAD:"${{ github.head_ref }}"
        fi

    - name: Deploy All Directories to Staging
      if: steps.dirs-to-process.outputs.no_dirs_to_process == 'false'
      run: |
        echo "🚀 Deploying all directories to staging bucket..."
        echo "📋 PR #${{ github.event.number }}: ${{ github.event.pull_request.title }}"
        echo ""
        
        PR_NUM="${{ github.event.number }}"
        STAGING_BUCKET="mlcommons-r2-infra-staging"
        STAGING_SUBDOMAIN="r2-infra-staging"
        deployed_count=0
        
        DIRS_TO_PROCESS="${{ steps.dirs-to-process.outputs.dirs }}"
        for folder_name in $DIRS_TO_PROCESS; do
          folder="${folder_name}/"
          if [ -f "${folder}manifest.json" ]; then
            
            # Skip if no index.html for non-central folders
            if [ "$folder" != "central/" ] && [ ! -f "${folder}index.html" ]; then
              echo "⏭️  Skipping ${folder_name} (no index.html found)"
              continue
            fi
            
            echo "📦 Deploying ${folder_name} to staging bucket path: $STAGING_BUCKET/$PR_NUM/${folder_name}"
            
            if [ "$folder" = "central/" ]; then
              echo "  └── Uploading all central resources..."
              rclone copy "$folder" r2-deploy:$STAGING_BUCKET/$PR_NUM/$folder_name --exclude "manifest.json" -v
            else
              echo "  └── Processing and uploading index.html..."
              # Create a temporary file with staging URLs
              temp_file=$(mktemp)
              # Rewrite central asset URLs and insert staging prefix before metadata filenames
              sed -E "\
                s|https://r2-infra\\.mlcommons-storage\\.org/central|https://${STAGING_SUBDOMAIN}.mlcommons-storage.org/$PR_NUM/central|g;\
                s|(https://[a-zA-Z0-9.-]+\.mlcommons-storage\.org/metadata/)staging-[0-9]+-?||g;\
                s|(https://[a-zA-Z0-9.-]+\.mlcommons-storage\.org/metadata/)|\1staging-${PR_NUM}-|g" "${folder}index.html" > "$temp_file"
              
              # Upload the modified file
              rclone copyto "$temp_file" r2-deploy:$STAGING_BUCKET/$PR_NUM/$folder_name/index.html -v
              
              # Clean up
              rm "$temp_file"
            fi
            
            echo "  ✅ ${folder_name} staging deployment complete"
            echo ""
            deployed_count=$((deployed_count + 1))
          else
            echo "⏭️  Skipping ${folder_name} (no manifest.json file found)"
          fi
        done
        
        echo "🎉 Staging deployment complete! Deployed $deployed_count folder(s) to $STAGING_BUCKET."
        echo ""
        
        echo "🔗 Staging URLs:"
        echo "  📋 Main staging bucket root: https://${STAGING_SUBDOMAIN}.mlcommons-storage.org/$PR_NUM/"
        echo ""
        echo "📄 Index pages:"
        DIRS_TO_PROCESS="${{ steps.dirs-to-process.outputs.dirs }}"
        for folder_name in $DIRS_TO_PROCESS; do
          folder="${folder_name}/"
          if [ -f "${folder}manifest.json" ]; then
            if [ "$folder" != "central/" ]; then
              echo "  🔗 ${folder_name}: https://${STAGING_SUBDOMAIN}.mlcommons-storage.org/$PR_NUM/${folder_name}/index.html"
            fi
          fi
        done
        echo ""
        echo "📦 Central resources:"
        if [ -f "central/manifest.json" ]; then
          echo "  🔗 Shared CSS: https://${STAGING_SUBDOMAIN}.mlcommons-storage.org/$PR_NUM/central/shared.css"
          echo "  🔗 Shared JS: https://${STAGING_SUBDOMAIN}.mlcommons-storage.org/$PR_NUM/central/shared.js"
          echo "  🔗 Shared content: https://${STAGING_SUBDOMAIN}.mlcommons-storage.org/$PR_NUM/central/shared-content.html"
        fi 
        
    - name: Comment PR with Staging URLs
      uses: actions/github-script@v7
      with:
        script: |
          const stagingSubdomain = 'r2-infra-staging';
          const prNumber = context.issue.number;
          
          // Build the comment body
          let comment = `## 🚀 Web files built and staged\n\n`;
          comment += `Your changes have been deployed to the staging environment and are ready for review!\n\n`;
          
          // Get list of directories that were processed
          const processedDirs = '${{ steps.dirs-to-process.outputs.dirs }}';
          const fs = require('fs');
          const folders = processedDirs.split(' ').filter(dir => {
            try {
              return dir && fs.existsSync(`${dir}/manifest.json`) && fs.existsSync(`${dir}/index.html`);
            } catch {
              return false;
            }
          });
          
          // Append list of changed web-related files vs main
          comment += `### 🔄 Web files changed vs \`main\`\n`;
          const { execSync } = require('child_process');
          execSync('git fetch --depth=1 origin main');
          const diffRaw = execSync('git diff --name-only origin/main HEAD -- "*/index.html" "central/*"').toString().trim();
          const changedFiles = diffRaw ? diffRaw.split('\n') : [];
          
          if (changedFiles.length) {
            changedFiles.forEach(f => {
              comment += `- \`${f}\`\n`;
            });
          } else {
            comment += 'No web file changes compared to main.';
          }
          
          // Now append dataset index pages section
          comment += `\n\n### 📄 Relevant dataset index pages\n\n`;
          
          // Add index page URLs (excluding central)
          folders.forEach(folder => {
            if (folder !== 'central') {
              comment += `- **${folder}**: https://${stagingSubdomain}.mlcommons-storage.org/${prNumber}/${folder}/index.html\n`;
            }
          });
          
          comment += `\n---\n`;
          comment += `*🤖 This comment was automatically generated by the staging deployment workflow.*`;
          
          // Check if we already have a comment from this workflow
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.data.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('Web files built and staged')
          );
          
          if (botComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          } 